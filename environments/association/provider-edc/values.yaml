tractusx-connector:
  enabled: true
  install:
    vault: false
  imagePullSecrets:
    - name: machineuser-pull-secret-ro
  participant:
    id: <path:semantics/data/provider-edc#participant-id>
  iatp:
    id: <path:semantics/data/provider-edc#iatp-id>
    trustedIssuers:
      - <path:semantics/data/provider-edc#iatp-trusted-issuers>
    sts:
      dim:
        url: <path:semantics/data/provider-edc#iatp-sts-dim-url>
      oauth:
        token_url: <path:semantics/data/provider-edc#iatp-sts-oauth-token-url>
        client:
          id: <path:semantics/data/provider-edc#iatp-sts-oauth-client-id>
          secret_alias: <path:semantics/data/provider-edc#iatp-sts-oauth-client-secretAlias>
  dataplane:
    image:
      repository: <path:semantics/data/provider-edc#dataplane-image-repository>
      tag: <path:semantics/data/provider-edc#dataplane-image-tag>
      pullPolicy: Always
    token:
      signer:
        privatekey_alias: <path:semantics/data/provider-edc#ec-private>
      verifier:
        publickey_alias: <path:semantics/data/provider-edc#ec-public>
    endpoints:
      # -- default api for health checks, should not be added to any ingress
      signaling:
        port: 9054
        path: /api/dataplane/signaling
      proxy:
        port: 9053
        path: /proxy
      public:
        port: 9051
        path: /public
    ingresses:
      - enabled: true
        hostname: <path:semantics/data/provider-edc#dataplane-hostname>
        annotations:
          cert-manager.io/cluster-issuer: letsencrypt-prod
          nginx.ingress.kubernetes.io/use-regex: "true"
          nginx.ingress.kubernetes.io/enable-cors: "true"
          nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
        certManager:
          clusterIssuer: letsencrypt-prod
        endpoints:
          - public
          - proxy
        className: nginx
        tls:
          enabled: true
    env:
      EDC_DPF_CONSUMER_PROXY: 9053
      EDC_DPF_SELECTOR_URL: <path:semantics/data/provider-edc#dpf-selector-url>
      EDC_HOSTNAME: <path:semantics/data/provider-edc#dataplane-hostname>
      EDC_GRANULAR_ACCESS_VERIFICATION_ERROR_ENDPOINT_PORT: 9054
      EDC_GRANULAR_ACCESS_VERIFICATION_EDC_DATA_PLANE_BASE_URL: <path:semantics/data/provider-edc#edc-access-verification-dataplane-url>
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_NAMES: default
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_CONFIG_DEFAULT_DTR_DECISION_CACHE_DURATION_MINUTES: 0
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_CONFIG_DEFAULT_DTR_ACCESS_VERIFICATION_ENDPOINT_URL: <path:semantics/data/provider-edc#dtr-access-verification-endpoint>
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_CONFIG_DEFAULT_ASPECT_MODEL_URL_PATTERN: <path:semantics/data/provider-edc#dtr-access-verification-aspect-pattern>
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_CONFIG_DEFAULT_OAUTH2_TOKEN_ENDPOINT_URL: <path:semantics/data/provider-edc#dtr-access-verification-oauth-token-url>
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_CONFIG_DEFAULT_OAUTH2_TOKEN_SCOPE: <path:semantics/data/provider-edc#dtr-access-verification-oauth-token-scope>
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_CONFIG_DEFAULT_OAUTH2_TOKEN_CLIENT_ID: <path:semantics/data/provider-edc#dtr-access-verification-oauth-token-client-id>
      EDC_GRANULAR_ACCESS_VERIFICATION_DTR_CONFIG_DEFAULT_OAUTH2_TOKEN_CLIENT_SECRET_PATH: <path:semantics/data/provider-edc#dtr-access-verification-oauth-token-client-secret>
  controlplane:
    image:
      repository: <path:semantics/data/provider-edc#controlplane-image-repository>
      tag: <path:semantics/data/provider-edc#controlplane-image-tag>
      pullPolicy: Always
    endpoints:
      # -- default api for health checks, should not be added to any ingress
      default:
        # -- port for incoming api calls
        port: 8080
        # -- path for incoming api calls
        path: /api
      # -- data management api, used by internal users, can be added to an ingress and must not be internet facing
      management:
        # -- port for incoming api calls
        port: 8081
        # -- path for incoming api calls
        path: /management
        # -- authentication key, must be attached to each 'X-Api-Key' request header
        authKey: <path:semantics/data/provider-edc#api-key>
      # -- control api, used for internal control calls. can be added to the internal ingress, but should probably not
      control:
        # -- port for incoming api calls
        port: 8083
        # -- path for incoming api calls
        path: /control
      # -- ids api, used for inter connector communication and must be internet facing
      protocol:
        # -- port for incoming api calls
        port: 8084
        # -- path for incoming api calls
        path: /api/v1/dsp
      # -- metrics api, used for application metrics, must not be internet facing
      metrics:
        # -- port for incoming api calls
        port: 9090
        # -- path for incoming api calls
        path: /metrics
    bdrs:
      server:
        url: <path:semantics/data/provider-edc#bdrs-server-url>
    ingresses:
      - enabled: true
        hostname: <path:semantics/data/provider-edc#controlplane-hostname>
        annotations:
          cert-manager.io/cluster-issuer: letsencrypt-prod
          nginx.ingress.kubernetes.io/use-regex: "true"
          nginx.ingress.kubernetes.io/enable-cors: "true"
          nginx.ingress.kubernetes.io/cors-allow-credentials: "true"
        certManager:
          clusterIssuer: letsencrypt-prod
        endpoints:
          - ids
          - management
          - protocol
          - default
        className: nginx
        tls:
          enabled: true
  vault:
    fullnameOverride: "vault"
    hashicorp:
      url: <path:semantics/data/provider-edc#vault-hashicorp-url>
      token: <path:semantics/data/provider-edc#vault-hashicorp-token>
      paths:
        secret:  <path:semantics/data/provider-edc#vault-hashicorp-secret-path>
        health: /v1/sys/health
    secretNames:
      transferProxyTokenSignerPrivateKey: <path:semantics/data/provider-edc#ec-private>
      transferProxyTokenSignerPublicKey: <path:semantics/data/provider-edc#ec-public>
      transferProxyTokenEncryptionAesKey: <path:semantics/data/provider-edc#aes-key>
  postgresql:
    resources:
      limits:
        cpu: 50m
        memory: 190mi
      requests:
        cpu: 50m
        memory: 120mi
simple-data-backend:
  enabled: true
  image:
    tag: "main"
  ingress:
    enabled: true
    ingressClassName: ""
    annotations:
      # uncomment the following line for tls
      kubernetes.io/ingress.class: addon-http-application-routing
      # nginx.ingress.kubernetes.io/proxy-body-size: 50m
      cert-manager.io/cluster-issuer: letsencrypt-prod
    hosts:
      - host: <path:semantics/data/provider-edc#simple-data-backend-url>
        paths:
          - path: "/"
            pathType: "ImplementationSpecific"
    tls:
      - secretName: "submodelserver.tx.test-tls"
        hosts:
          - <path:semantics/data/provider-edc#simple-data-backend-url>
